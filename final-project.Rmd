---
title: "final-project"
author: "Shaina Trevino"
date: "5/16/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(rio)
library(tidyverse)
```

## Importing data

```{r import}
drug_by_year <- import(here("data", "drug_by_year.csv"),
                       setclass = "tbl_df")

recent_drug <- import(here("data", "2015_drug_dep.csv"),
                      setclass = "tbl_df")
```

#### Info about the data:

`drug_by_year` has data from 2005 to 2015 and reports on the people who responded yes to using illicit substances in the last year. 

`recent_drug` has data from 2015-2016 (most recent NHANES data available) and shows the age of first drug use, a summed depression score, whether or not participants have been to rehab, have access to mental health services, and have health insurance. 
  * `age_stim` is a composite measure of age of first meth and cocaine use (e.g., age of first stimulant use)

# Tutorial

## Introduction

What is looping/iterating

What is Functional Programming

## How to use `purrr::map`!

* More than one variant of `purrr::map` is used 

LIST ALL VARIANTS OF PURRR:MAP AND EXPLAIN DIFFERENCES - SHOW 2 TYPES

1. purrr:map is a functional. It takes a vector and a function as an input, runs the function for each element in the vector, and then returns a list.

  * It is loaded in the tidyverse
  
  * can override return of list and instead return an atomic vector by using variants of map:
  
    * `map_dbl` returns vector of type double
    
    * `map_chr` returns a vector of type character
    
    * `map_lgl` returns a vector of type logical (e.g., `TRUE` or `FALSE`)
    
    * `map_int` returns a vector of type integer
    

```{r map-ex}
v <- c(1.85, 2.07, 3.71, 4.21, 5.36)
#takes vector and rounds up - returns list
map(v, round)
#return vector of type double
map_dbl(v, round)
#return vector as character
map_chr(v, round)

#return vector of type logical - is each element of type double
map_lgl(v, is.double)

#return vector of type integer - how many elements are in each element - here it is only 1
map_int(v, length)
```

Since `map` requires a vector for an input, and data frames are lists containing vectors, you can use `map` to iterate through dataframes. 

For example, say we have this data (EXPLAIN DATA) and we want to calculate mean for age of first use and depression sum. Since there is quite a bit of missing data, we need to add arguments to the mean function.  

We would do so by creating an inline anonymous function

```{r summarize}
#mean and sd
d <- recent_drug %>% 
  select(age_cocaine:sum_depression)

means <- map_dbl(d, function(x) mean(x, na.rm = TRUE)) #explain x is a place holder
means

#same result, less code.

means <- map_dbl(d, ~ mean(.x, na.rm = TRUE))
means
```

  
* At least one instance of parallel iteration (e.g., `map2_*`, `pmap_*`) 

EXPLAIN BOTH MAP 2 AND PMAP AND SHOW HOW PMAP WORKS WITH PLOT (BEFORE WALK? - SEE MIDTERM)

The `map` variants discussed above all take a single...

* At least one {purrr} function outside the basic `map` family (`walk_*`, 
  `reduce`, `modify_*`, etc.) 

The `map()` variants discussed above all return an output (either an atomic vector or list). However, sometimes you don't need to return an atomic vector or list, but iteration would still be helpful.
  
Very useful variant of `map()` is `walk()`, specifically `walk2()` which can be used to save objects to a disk. Note: when saving something to a disk you have to provide 2 inputs: the object and the file path - this requires parallel iteration.   

```{r walk-ex, eval = FALSE}
by_year <- split(drug_by_year, drug_by_year$year)
paths <- here("data", paste0("year-", names(by_year), ".csv"))
walk2(by_year, paths, write.csv)
#splits our longitudinal dataset by year and saves separate csv file for each year with the title ("year-2005") in the data folder of the working directory

list.files("data")
```

`reduce()` takes a vector of any length as it's input and returns a vector of length 1. For example `reduce(1:4, f)` returns `f(f(f(1, 2), 3), 4)`. 

`modify()` returns the same type of input it is provided. For example, `modify(df, f)` will run the function on each column of the dataframe and return a dataframe as the output.
  
EXPLAIN ALL (MOSTLY WALK) AND SHOW HOW IT IS USED - FOR PLOT EXAMPLE - SEE MIDTERM

* At least one use case of `purrr::nest %>% mutate()` 

EXPLAIN LIST COLUMNS AND USE FOR GROUPING STATS (e.g., group by drug and year then calculate age of use etc.) - POSSIBLY ON MIDTERM OR MACHINE LEARNING


## Requirements per syllabus

* *No code is used repetitively (no more than twice)*
* More than one variant of `purrr::map` is used 
* At least one {purrr} function outside the basic `map` family (`walk_*`, 
  `reduce`, `modify_*`, etc.) 
* At least one instance of parallel iteration (e.g., `map2_*`, `pmap_*`) 
* At least one use case of `purrr::nest %>% mutate()` 
* At least two custom functions 
	+ Each function must be "pure" unless it is clear that it should have side 
	  effects (e.g., a plotting function)
  + Each function must do exactly one thing
  + The functions **may** replicate the behavior of a base function - as noted 
    above this is about practicing the skills you learn in class
* Code is fully reproducible and housed on GitHub 
* No obvious errors in chosen output format 
* Deployed on the web and shareable through a link 

