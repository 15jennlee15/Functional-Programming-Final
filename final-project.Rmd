---
title: "final-project"
author: "Shaina Trevino"
date: "5/16/2019"
output: 
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(rio)
library(tidyverse)
library(broom)
```

## Importing data

```{r import}
drug_by_year <- import(here("data", "drug_by_year.csv"),
                       setclass = "tbl_df")

recent_drug <- import(here("data", "2015_drug_dep.csv"),
                      setclass = "tbl_df")
```

#### Info about the data:

`drug_by_year` has data from 2005 to 2015 and reports on the people who responded yes to using illicit substances in the last year. 

`recent_drug` has data from 2015-2016 (most recent NHANES data available) and shows the age of first drug use, a summed depression score, whether or not participants have been to rehab, have access to mental health services, and have health insurance. 
  * `age_stim` is a composite measure of age of first meth and cocaine use (e.g., age of first stimulant use)

# Tutorial

## Introduction

What is looping/iterating

What is Functional Programming

## How to use `purrr::map`!

#### * More than one variant of `purrr::map` is used 

LIST ALL VARIANTS OF PURRR:MAP AND EXPLAIN DIFFERENCES - SHOW 2 TYPES

1. purrr:map is a functional. It takes a vector and a function as an input, runs the function for each element in the vector, and then returns a list.

  * It is loaded in the tidyverse
  
  * can override return of list and instead return an atomic vector by using variants of map:
  
    * `map_dbl` returns vector of type double
    
    * `map_chr` returns a vector of type character
    
    * `map_lgl` returns a vector of type logical (e.g., `TRUE` or `FALSE`)
    
    * `map_int` returns a vector of type integer
    

```{r map-ex}
v <- c(1.85, 2.07, 3.71, 4.21, 5.36)
#takes vector and rounds up - returns list
map(v, round)
#return vector of type double
map_dbl(v, round)
#return vector as character
map_chr(v, round)

#return vector of type logical - is each element of type double
map_lgl(v, is.double)

#return vector of type integer - how many elements are in each element - here it is only 1
map_int(v, length)
```

Since `map` requires a vector for an input, and data frames are lists containing vectors, you can use `map` to iterate through dataframes. 

For example, say we have this data (EXPLAIN DATA) and we want to calculate mean for age of first use and depression sum. Since there is quite a bit of missing data, we need to add arguments to the mean function.  

We would do so by creating an inline anonymous function

```{r summarize}
#mean and sd
d <- recent_drug %>% 
  select(age_cocaine:sum_depression)

means <- map_dbl(d, function(x) mean(x, na.rm = TRUE)) #explain x is a place holder
means

#same result, less code.

means <- map_dbl(d, ~ mean(.x, na.rm = TRUE))
means


```

Can also use map_df to return data frame instead of atomic vector. 

Say we want to return data frame of mean and standard deviations of each column

```{r map-df}
#you would expect this to work, but doesn't because only the last line in the function is being evaluated and printed
map_df(d, function(x) {
  mean(x, na.rm = TRUE)
  sd(x, na.rm = TRUE)
})

column_names <- colnames(d)
#need to instead
map_df(d, function(x) {
  summarize(d, mean = mean(x, na.rm = TRUE),
            sd = sd(x, na.rm = TRUE))
}, .id = "column_names")

#or you could do this in two separate steps, using map for looping the functions through vectors then putting vectors into dataframe
mean <- map(d, ~mean(.x, na.rm = TRUE))
sd <- map(d, ~sd(.x, na.rm = TRUE))
#combine vectors
cv <- c(mean, sd, recursive = TRUE)
#change attributes
attr(cv, "dim") <- c(6, 2) #6 variables in two columns (mean and sd)
colnames(cv) <- c("mean", "sd")
#transform to dataframe
data.frame(cv, row.names = column_names)
```

  
#### * At least one instance of parallel iteration (e.g., `map2_*`, `pmap_*`) 

EXPLAIN BOTH MAP 2 AND PMAP AND SHOW HOW PMAP WORKS WITH PLOT (BEFORE WALK? - SEE MIDTERM)

The `map` variants discussed above all take a single...

```{r parallel}

```


#### * At least one {purrr} function outside the basic `map` family (`walk_*`, `reduce`, `modify_*`, etc.) 

The `map()` variants discussed above all return an output (either an atomic vector or list). However, sometimes you don't need to return an atomic vector or list, but iteration would still be helpful.
  
Very useful variant of `map()` is `walk()`, specifically `walk2()` which can be used to save objects to a disk. Note: when saving something to a disk you have to provide 2 inputs: the object and the file path - this requires parallel iteration.   

```{r walk-ex, eval = FALSE}
by_year <- split(drug_by_year, drug_by_year$year)
paths <- here("data", paste0("year-", names(by_year), ".csv"))
walk2(by_year, paths, write.csv)
#splits our longitudinal dataset by year and saves separate csv file for each year with the title ("year-2005") in the data folder of the working directory

list.files("data")
```

`reduce()` takes a vector of any length as it's input and returns a vector of length 1. For example `reduce(1:4, f)` returns `f(f(f(1, 2), 3), 4)`. 

`modify()` returns the same type of input it is provided. For example, `modify(df, f)` will run the function on each column of the dataframe and return a dataframe as the output.
  
EXPLAIN ALL (MOSTLY WALK) AND SHOW HOW IT IS USED - FOR PLOT EXAMPLE - SEE MIDTERM

#### * At least one use case of `purrr::nest %>% mutate()` 

EXPLAIN LIST COLUMNS AND USE FOR GROUPING STATS (e.g., group by drug and year then calculate age of use etc.)

```{r nest-mutate1}
dat <- recent_drug %>% 
  select(-1:-2, -age_stim) %>% 
  pivot_longer(cols = age_cocaine:age_marijuana, names_to = c("dis", "drug"), names_sep = "_") %>% 
  select(-dis) %>% 
  rename(age_use = value) %>% 
  filter(!is.na(age_use)) %>% 
  mutate(mental_health = ifelse(mental_health == "Yes", "Yes", "No"),
         sex = fct_relevel(sex, ref = "Male"),
         mental_health = fct_relevel(mental_health, ref = "No"))

#fit one model per drug and see coefficients
by_drug_coefs <- dat %>% 
  group_by(drug) %>% 
  nest() %>% 
  mutate(model = map(data, ~lm(age_use ~ sex, data = .x)),
         coef = map(model, ~tidy(.x))) %>% 
  unnest(coef)

#Look at model fit stats per drug model - will be bad
by_drug_fit <- dat %>% 
  group_by(drug) %>% 
  nest() %>% 
  mutate(model = map(data, ~lm(age_use ~ sex, data = .x)),
         fit = map(model, ~glance(.x))) %>% 
  unnest(fit)

#mean age of use for males and females in first model
by_drug_sex <- dat %>% 
  group_by(drug) %>% 
  nest() %>% 
  mutate(model = map(data, ~lm(age_use ~ sex, data = .x)),
         coefs = map(model, coef),
         males = map_dbl(coefs, 1),
         females = males + map_dbl(coefs, 2)) %>% 
  select(drug, males, females)

#fit multiple models by year
by_drug_models <- dat %>% 
  group_by(drug) %>% 
  nest() %>% 
  mutate(m1 = map(data, ~lm(age_use ~ sex, data = .x)),
         m2 = map(data, ~lm(age_use ~ sex + mental_health, data = .x)),
         m3 = map(data, ~lm(age_use ~ sex * mental_health, data = .x)))


```


```{r nest-mutate, eval = FALSE, include = FALSE}
d_long <- drug_by_year %>% 
  select(-V1, -ethnicity) %>% 
  mutate(year = factor(year),
         drug = factor(drug),
         sex = factor(sex),
         response = factor(response))

by_year_drug <- d_long %>% 
  group_by(year, drug, count) %>% 
  nest() %>% 
  mutate(count = map(data, ~mutate(.x, count = n())))
```





## Requirements per syllabus

* *No code is used repetitively (no more than twice)*
* More than one variant of `purrr::map` is used 
* At least one {purrr} function outside the basic `map` family (`walk_*`, `reduce`, `modify_*`, etc.) 
* At least one instance of parallel iteration (e.g., `map2_*`, `pmap_*`) 
* At least one use case of `purrr::nest %>% mutate()` 

* At least two custom functions 
	+ Each function must be "pure" unless it is clear that it should have side 
	  effects (e.g., a plotting function)
  + Each function must do exactly one thing
  + The functions **may** replicate the behavior of a base function - as noted 
    above this is about practicing the skills you learn in class
* Code is fully reproducible and housed on GitHub 
* No obvious errors in chosen output format 
* Deployed on the web and shareable through a link 

